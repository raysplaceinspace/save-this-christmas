pub prop World.NumMonstersDestroyed = 0
pub collect World.AllMonsters

prop monster.FlipMonster

pub fn monster.LittleMonster(pos) {
    Monster(pos=, speed=5, radius=0.5*TileRadius)
}
pub fn monster.MediumMonster(pos) {
    Monster(pos=, speed=3, radius=0.75*TileRadius)
}
pub fn monster.BigMonster(pos) {
    Monster(pos=, speed=1.5, radius=1*TileRadius)
}


let DistancesToGifts = null
pub fn World.MonsterNavigationSystem() {
    on Tick {
        while AllMonsters.IsEmpty {
            await AllMonsters
        }
        let costs = await CalculateMonsterNavCosts
        DistancesToGifts = await CalculateDistanceField(AllGifts, costs=)
    }
}

fn monster.Monster(pos, speed=3, radius=TileRadius) {
    use body=monster
    use acceleration=0.5
    use color=#0f0, layer=Layer:Monster
    
    Body(pos=, noRotation=true)
    PolygonCollider(shape=Circle, category=Category:Monster)
    PolygonSprite(Circle(radius=0), bloom=7, luminous=1, layer=Layer:Glow)

    with FlipMonster {
        ImageSprite(
            @grouch*.png,
            radius=1.5*radius,
            screenOffset=@(0,-0.25),
            shadow=0.25,
            bodyScale=FlipMonster ? @(-1, 1) : @(1, 1),
        )
    }

    give AllMonsters(monster)
    
    DecaySpeed(0.05)

    on BeforePhysics {
        let direction = CalculateDirectionToGift(Pos)
        if !direction { continue }

        Velocity = (Velocity + acceleration*direction).Truncate(speed)

        if direction.X != 0 {
            FlipMonster = direction.X < 0
        }
    }

    on BeforeCollide that {
        if that.Category.Overlaps(Category:Hero) {
            NumMonstersDestroyed += 1
            repeat 5 { Spark(splatter=1, speed=10, luminous=1, bloom=3, glare=1) }
            Expire
        } else if that.Category.Overlaps(Category:Gift) {
            Expire
        }
    }
}

fn CalculateDirectionToGift(pos) -> direction {
    let gift = pos.QueryNearest(filter=Category:Gift)
    if !gift { return undefined } // No gifts remaining
    
    // Walk straight to the nearest gift if nothing is in the way
    let directionToNearestGift = Direction(gift.Pos - pos)
    if pos.QueryNearestAlongRay(direction=directionToNearestGift).Category.Overlaps(Category:Gift) {
        return directionToNearestGift
    }

    // Otherwise, use pathfinding if possible
    let waypoint = CalculateNavWaypoint(pos=, distances=DistancesToGifts)
    if waypoint {
        return Direction(waypoint - pos)
    }

    return directionToNearestGift
}

await fn CalculateMonsterNavCosts(iterationsPerTick=100) -> costs {
    let costs = []

    for numIterations, index in Range(0, NumRows*NumCols) {
        let pos = TileIndexToPos(index)
        let cost = 1
        if pos.QueryAnyOverlapping(filter=Category:Crate) {
            cost += 5
        }
        if pos.QueryAnyOverlapping(filter=Category:Obstacle | Category:Hero) {
            cost += 100
        }
        costs.Push(cost)

        if numIterations % iterationsPerTick == 0 { await Tick }
    }

    for hero in Query(filter=Category:Hero) {
        let heroPos = hero.Pos
        for colOffset in RangeInclusive(-2, 2) {
            for rowOffset in RangeInclusive(-2, 2) {
                let pos = @(heroPos.X + TileSize*colOffset, heroPos.Y + TileSize*rowOffset)
                let index = PosToTileIndex(pos)
                if index.IsNullish { continue }
                costs[index] += (5 - Distance(heroPos, pos)) / TileSize
            }
        }
    }
    
    return costs
}