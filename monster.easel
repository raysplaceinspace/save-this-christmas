pub collect World.AllMonsters

pub fn monster.LittleMonster(pos) {
    Monster(pos=, speed=5, radius=0.5*TileRadius)
}
pub fn monster.MediumMonster(pos) {
    Monster(pos=, speed=3, radius=0.75*TileRadius)
}
pub fn monster.BigMonster(pos) {
    Monster(pos=, speed=1.5, radius=1*TileRadius)
}

fn monster.Monster(pos, speed=3, radius=TileRadius) {
    use body=monster
    use acceleration=0.5
    use color=#0f0, layer=Layer:Monster
    
    Body(pos=, noRotation=true)
    PolygonCollider(shape=Circle, category=Category:Monster)
    PolygonSprite(Circle(radius=0), bloom=7, luminous=1, layer=Layer:Glow)
    ImageSprite(@grouch.png, radius=1.5*radius, screenOffset=@(0,-0.25), shadow=0.25)

    give AllMonsters(monster)
    
    DecaySpeed(0.05)

    on BeforePhysics {
        let direction = CalculateDirectionToGift(Pos)
        if !direction { continue }

        Velocity = (Velocity + acceleration*direction).Truncate(speed)
    }

    on BeforeCollide that {
        if that.Category.Overlaps(Category:Hero) {
            repeat 5 { Spark(speed=10, luminous=1) }
            Expire
        }
    }
}

let distancesToGifts = null
fn CalculateDirectionToGift(pos) -> direction {
    if !distancesToGifts {
        distancesToGifts = CalculateDistanceField(AllGifts, costs=CalculateMonsterNavCosts)
    
        // After everything moves because of the physics step,
        // the distance field needs to be updated.
        // Put this behavior on World so there is only one globally
        {
            use this=World
            once AfterPhysics {
                distancesToGifts = null
            }
        }
    }

    let gift = pos.QueryNearest(filter=Category:Gift)
    if !gift { return undefined } // No gifts remaining
    
    // Walk straight to the nearest gift if nothing is in the way
    let directionToNearestGift = Direction(gift.Pos - pos)
    if pos.QueryNearestAlongRay(direction=directionToNearestGift).Category.Overlaps(Category:Gift) {
        return directionToNearestGift
    }

    // Otherwise, use pathfinding if possible
    let waypoint = CalculateNavWaypoint(pos=, distances=distancesToGifts)
    if waypoint {
        return Direction(waypoint - pos)
    }

    return directionToNearestGift
}

fn CalculateMonsterNavCosts() -> costs {
    let costs = []
    
    for index in Range(0, NumRows*NumCols) {
        let pos = TileIndexToPos(index)
        let cost = 1
        if pos.QueryAnyOverlapping(filter=Category:Crate) {
            cost += 5
        }
        if pos.QueryAnyOverlapping(filter=Category:Obstacle | Category:Hero) {
            cost += 100
        }
        costs.Push(cost)
    }

    for hero in Query(filter=Category:Hero) {
        let heroPos = hero.Pos
        for colOffset in RangeInclusive(-2, 2) {
            for rowOffset in RangeInclusive(-2, 2) {
                let pos = @(heroPos.X + TileSize*colOffset, heroPos.Y + TileSize*rowOffset)
                let index = PosToTileIndex(pos)
                if index.IsNullish { continue }
                costs[index] += (5 - Distance(heroPos, pos)) / TileSize
            }
        }
    }
    
    return costs
}