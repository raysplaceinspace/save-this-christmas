pub fn CalculateDistanceField(sources, costs) -> distances {
    use distances = []
    use closeQueue = [] // queue with neighbors only gets priority
    use farQueue = [] // everything else
    for source in sources {
        let index = PosToTileIndex(@(source.Pos.X.Truncate(BoundaryRadiusX), source.Pos.Y.Truncate(BoundaryRadiusY)))
        if index.IsNullish { continue }
        distances[index] = 0
        closeQueue.Push(index)
    }

    let numIterations = 0
    loop {
        let index = closeQueue.Shift
        if index.IsNullish {
            index = farQueue.Shift
            if index.IsNullish { break }
        }
        
        let parentDistance = distances[index]
        let pos = TileIndexToPos(index)

        TryEnqueueNeighbor(pos=@(pos.X - TileSize, pos.Y), parentDistance=)
        TryEnqueueNeighbor(pos=@(pos.X + TileSize, pos.Y), parentDistance=)
        TryEnqueueNeighbor(pos=@(pos.X, pos.Y - TileSize), parentDistance=)
        TryEnqueueNeighbor(pos=@(pos.X, pos.Y + TileSize), parentDistance=)

        numIterations += 1
    }
    return distances
}

pub fn CalculateNavWaypoint(pos, distances) -> vector {
    let index = PosToTileIndex(pos)
    if index.IsNullish { return undefined }
    
    let distance = distances[index]
    if distance.IsNullish { return undefined }

    let waypoint = @(pos.X, pos.Y - TileSize)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    waypoint = @(pos.X, pos.Y + TileSize)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    waypoint = @(pos.X - TileSize, pos.Y)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    waypoint = @(pos.X + TileSize, pos.Y)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    return undefined
}

pub fn PosToTileIndex(pos) -> index {
    let col = Round((pos.X + BoundaryRadiusX) / TileSize)
    if col < 0 || col >= NumCols { return undefined }
    
    let row = Round((pos.Y + BoundaryRadiusY) / TileSize)
    if row < 0 || row >= NumRows { return undefined }

    return row*NumCols + col
}

pub fn TileIndexToPos(index) -> pos {
    let col = index % NumCols
    let row = Floor(index / NumCols)
    return @(col*TileSize - BoundaryRadiusX, row*TileSize - BoundaryRadiusY)
}

fn TryEnqueueNeighbor(pos, parentDistance, [costs, distances, closeQueue, farQueue]) {
    let index = PosToTileIndex(pos)
    if index.IsNullish { return }

    let cost = costs[index]
    let distance = parentDistance + cost

    let previousDistance = distances[index]
    if previousDistance <= distance { return }
    
    distances[index] = distance

    if cost <= 1 {
        closeQueue.Push(index)
    } else {
        farQueue.Push(index)
    }
}