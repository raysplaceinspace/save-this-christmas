pub fn CalculateDistanceField(sources) -> distances {
    let distances = []
    let queue = []
    for source in sources {
        let index = PosToTileIndex(source.Pos)
        distances[index] = 0
        queue.Push(index)
    }

    let numIterations = 0
    while !queue.IsEmpty {
        let index = queue.Shift
        let nextDistance = distances[index] + 1
        let pos = TileIndexToPos(index)

        TryEnqueueNeighbor(pos=@(pos.X - TileSize, pos.Y), distance=nextDistance, distances=, queue=)
        TryEnqueueNeighbor(pos=@(pos.X + TileSize, pos.Y), distance=nextDistance, distances=, queue=)
        TryEnqueueNeighbor(pos=@(pos.X, pos.Y - TileSize), distance=nextDistance, distances=, queue=)
        TryEnqueueNeighbor(pos=@(pos.X, pos.Y + TileSize), distance=nextDistance, distances=, queue=)

        numIterations += 1
    }
    return distances
}

pub fn CalculateNavWaypoint(pos, distances) -> vector {
    let index = PosToTileIndex(pos)
    if index.IsNullish { return undefined }
    
    let distance = distances[index]
    if distance.IsNullish { return undefined }

    let waypoint = @(pos.X - TileSize, pos.Y)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    waypoint = @(pos.X + TileSize, pos.Y)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    waypoint = @(pos.X, pos.Y - TileSize)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    waypoint = @(pos.X, pos.Y + TileSize)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    return undefined
}

fn PosToTileIndex(pos) -> index {
    let col = Round((pos.X + BoundaryRadiusX) / TileSize)
    if col < 0 || col >= NumCols { return undefined }
    
    let row = Round((pos.Y + BoundaryRadiusY) / TileSize)
    if row < 0 || row >= NumRows { return undefined }

    return row*NumCols + col
}

fn TileIndexToPos(index) -> pos {
    let col = index % NumCols
    let row = Floor(index / NumCols)
    return @(col*TileSize - BoundaryRadiusX, row*TileSize - BoundaryRadiusY)
}

fn IsTilePassable(pos) -> boolean {
    return !pos.QueryAnyOverlapping(pos, filter=Category:Obstacle, solids=true, sensors=false)
}

fn TryEnqueueNeighbor(pos, distance, distances, queue) {
    let index = PosToTileIndex(pos)
    if index.IsNullish { return }

    let previousDistance = distances[index]
    if previousDistance <= distance { return }

    if previousDistance == null { return } // Marked as impassable
    if !IsTilePassable(pos=) {
        distances[index] = null
        return
    }
    
    distances[index] = distance
    queue.Push(index)
}