pub fn CalculateDistanceField(sources, costs) -> distances {
    use distances = []
    use queue = []
    for source in sources {
        let index = PosToTileIndex(@(source.Pos.X.Truncate(BoundaryRadiusX), source.Pos.Y.Truncate(BoundaryRadiusY)))
        if index.IsNullish { continue }
        distances[index] = 0
        queue.Push(index)
    }

    let numIterations = 0
    while !queue.IsEmpty {
        let index = queue.Shift
        let parentDistance = distances[index]
        let pos = TileIndexToPos(index)

        TryEnqueueNeighbor(pos=@(pos.X - TileSize, pos.Y), parentDistance=)
        TryEnqueueNeighbor(pos=@(pos.X + TileSize, pos.Y), parentDistance=)
        TryEnqueueNeighbor(pos=@(pos.X, pos.Y - TileSize), parentDistance=)
        TryEnqueueNeighbor(pos=@(pos.X, pos.Y + TileSize), parentDistance=)

        numIterations += 1
    }
    return distances
}

pub fn CalculateNavWaypoint(pos, distances) -> vector {
    let index = PosToTileIndex(pos)
    if index.IsNullish { return undefined }
    
    let distance = distances[index]
    if distance.IsNullish { return undefined }

    let waypoint = @(pos.X, pos.Y - TileSize)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    waypoint = @(pos.X, pos.Y + TileSize)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    waypoint = @(pos.X - TileSize, pos.Y)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    waypoint = @(pos.X + TileSize, pos.Y)
    if distances[PosToTileIndex(waypoint)] < distance { return waypoint }

    return undefined
}

pub fn PosToTileIndex(pos) -> index {
    let col = Round((pos.X + BoundaryRadiusX) / TileSize)
    if col < 0 || col >= NumCols { return undefined }
    
    let row = Round((pos.Y + BoundaryRadiusY) / TileSize)
    if row < 0 || row >= NumRows { return undefined }

    return row*NumCols + col
}

pub fn TileIndexToPos(index) -> pos {
    let col = index % NumCols
    let row = Floor(index / NumCols)
    return @(col*TileSize - BoundaryRadiusX, row*TileSize - BoundaryRadiusY)
}

fn TryEnqueueNeighbor(pos, parentDistance, [costs, distances, queue]) {
    let index = PosToTileIndex(pos)
    if index.IsNullish { return }

    let distance = parentDistance + costs[index]

    let previousDistance = distances[index]
    if previousDistance <= distance { return }
    
    distances[index] = distance
    queue.Push(index)
}